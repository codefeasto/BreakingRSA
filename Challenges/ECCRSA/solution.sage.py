

# This file was *autogenerated* from the file solution.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_256 = Integer(256); _sage_const_224 = Integer(224); _sage_const_192 = Integer(192); _sage_const_96 = Integer(96); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_41058363725152142129326129780047268409114441015993725554835256314039467401291 = Integer(41058363725152142129326129780047268409114441015993725554835256314039467401291); _sage_const_115792089210356248762697446949407573529996955224135760342422259061068512044369 = Integer(115792089210356248762697446949407573529996955224135760342422259061068512044369); _sage_const_2532601576517180151973272804472458662188911309902804927674973120731632668465722549385259120121020332032083313975900081376517867702500494081504179013647029 = Integer(2532601576517180151973272804472458662188911309902804927674973120731632668465722549385259120121020332032083313975900081376517867702500494081504179013647029); _sage_const_65537 = Integer(65537); _sage_const_64249798141205617809160223067814527035042879912280536230689430488390850022518 = Integer(64249798141205617809160223067814527035042879912280536230689430488390850022518); _sage_const_45923098905078689255634808917746174708164700128176753039048172835317590674783 = Integer(45923098905078689255634808917746174708164700128176753039048172835317590674783); _sage_const_4 = Integer(4); _sage_const_0 = Integer(0)
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP


###### NIST P256 
p256 = _sage_const_2 **_sage_const_256 -_sage_const_2 **_sage_const_224 +_sage_const_2 **_sage_const_192 +_sage_const_2 **_sage_const_96 -_sage_const_1 
a256 = p256 - _sage_const_3 
b256 = _sage_const_41058363725152142129326129780047268409114441015993725554835256314039467401291 
## Curve order
n = _sage_const_115792089210356248762697446949407573529996955224135760342422259061068512044369 
FF = GF(p256)
EC = EllipticCurve([FF(a256), FF(b256)])
EC.set_order(n)

N = _sage_const_2532601576517180151973272804472458662188911309902804927674973120731632668465722549385259120121020332032083313975900081376517867702500494081504179013647029 
e = _sage_const_65537 
S = EC(_sage_const_64249798141205617809160223067814527035042879912280536230689430488390850022518 , _sage_const_45923098905078689255634808917746174708164700128176753039048172835317590674783 )
ciphertext = b'\x12\xed\xb1r\xb0L]\xcff\x9b\xb1o\x88\xd3\xc9\xac~P{\x0e\x1e\x12:\x8e\xae<\xeb\xc8\x11\xc5\x94\xbfs\x9es,\xb5\xc6f\xcc\xbf\xc8\xb7\xe3\xa0\x1e;XhO A`\x92\x9f\xa1\xbbZ^\xe5\xf8\xc2@t'

Sx, Sy = S.xy()
# n = p*q
# Sx = l^2 - p - q
# Sy = l*(p - Sx) - Y(p)

a = a256
b = b256

P = PolynomialRing(FF, names=('xp', 'xq', 'yp', 'yq',)); (xp, xq, yp, yq,) = P._first_ngens(4)
p1 = yp**_sage_const_2  - (xp**_sage_const_3  + a*xp + b)
p2 = yq**_sage_const_2  - (xq**_sage_const_3  + a*xq + b)

pol1 = (yq - yp)**_sage_const_2  - xp*(xq - xp)**_sage_const_2  - xq*(xq - xp)**_sage_const_2  - Sx*(xq - xp)**_sage_const_2 
pol2 = (yq - yp)*(xp - Sx) - yp*(xq - xp) - Sy*(xq - xp)
pol3 = N - xp*xq

I = P * (p1, p2, pol1, pol2, pol3)
V = I.groebner_basis()
# print monomials of the polynomials in the groebner basis to inspect them manually and select appropriate ones to use resultant on
print(*[Vi.monomials() for Vi in V], sep= '\n')
print(len(V))


V1, V2, V3, V4 = V[:_sage_const_4 ]

def resultant(p1, p2, var):
    p1 = p1.change_ring(QQ)
    p2 = p2.change_ring(QQ)
    var = var.change_ring(QQ)
    r = p1.resultant(p2, var)
    return r.change_ring(FF)


# Get rid of variables
h12 = resultant(V1, V2, xp) 
h34 = resultant(V3, V4, xp) 
h1234 = resultant(h12, h34, yp)
print(h1234.variables())

# this polynomial only has one variable, so finding roots is trivial
unipol = resultant(h1234, p2, yq).univariate_polynomial()

poss_xq = unipol.roots(multiplicities= False)
print(poss_xq)
for r in poss_xq:
    if N % int(r) == _sage_const_0 :
        print("success")
        p = int(r)
        e = _sage_const_65537 
        q = N//p
        print(f"{p = }")
        print(f"{q = }")
        assert is_prime(p), is_prime(q)
        assert p*q == N
        phi = (p - _sage_const_1 ) * (q - _sage_const_1 )

        d = int(pow(e, -_sage_const_1 , phi))

        key = RSA.construct((int(N), int(e), int(d)))
        cipher = PKCS1_OAEP.new(key)
        ciphertext = b'\x12\xed\xb1r\xb0L]\xcff\x9b\xb1o\x88\xd3\xc9\xac~P{\x0e\x1e\x12:\x8e\xae<\xeb\xc8\x11\xc5\x94\xbfs\x9es,\xb5\xc6f\xcc\xbf\xc8\xb7\xe3\xa0\x1e;XhO A`\x92\x9f\xa1\xbbZ^\xe5\xf8\xc2@t'

        message = cipher.decrypt(ciphertext)
        print(message)
        exit()




